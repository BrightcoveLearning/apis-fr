---
title: 'Créer un <span translate="No">Jeton Web JSON</span> (JWT)'
description: 'Dans cette rubrique, vous apprendrez à créer un <span translate="No">Jeton Web JSON</span> (JWT) qui peut être utilisé lors de la communication avec l'API de lecture Brightcove.'
parent: Guides 
grandparent: Playback Authorization
layout: staging
---
 <h1>{{ page.title }}</h1>
<script>
  var BCLS = ( fonction (fenêtre, document) { var newURL = 'https://general.support.brightcove.com/developer/create-jwt-stage.html', message = 'This page has moved to the Integrations site. The new url is: ' + newURL + ' You will be redirected in 5 seconds. Please update your bookmarks.', t; function goToNewURL() { window.location.href = newURL; } document.write(message); t = window.setTimeout(goToNewURL, 5000); })(fenêtre, document);
</script>

<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <br>
  <aside class="bcls-aside bcls-aside--tip">Cette fonctionnalité est disponible pour un ensemble spécifique de clients ayant accès à la phase de disponibilité limitée du service d'autorisation de lecture.</aside>

  <section class="bcls-section">
<h2 id="Introduction">introduction</h2>

<p>Pour ajouter un niveau de protection supplémentaire lors de l'accès à votre vidéothèque, ou pour appliquer des restrictions au niveau utilisateur pour votre contenu, vous pouvez passer un <span translate="No">Jeton Web JSON</span> (JWT) avec votre appel à l'API de lecture Brightcove. Pour créer le jeton, procédez comme suit :</p>
<ol class="bcls-tasklist">
	<li><a href="#Generate_public_private_key_pair">Générer une paire de clés publique-privée</a></li>
  <li>
    <a href="#Register_public_key">Enregistrer la clé publique avec Brightcove</a>
  </li>
  <li>
    <a href="#Create_a_JSON_Web_Token">Créer un <span translate="No">Jeton Web JSON</span></a>
  </li>
  <li>
    <a href="#Test_playback">Tester la lecture</a>
  </li>
</ol>


</section>

<section class="bcls-section">
<h2 id="Generate_public_private_key_pair">Générer une paire de clés publique-privée</h2>

<p>L'éditeur générera une paire de clés publique-privée et fournira la clé publique à Brightcove. La clé privée est utilisée par l'éditeur pour signer les jetons et n'est pas partagée avec Brightcove.</p>

<p>
  Il existe de nombreuses façons de générer la paire de clés publique-privée. Voici quelques exemples:
</p>
<h3>
  Exemple de script bash :
</h3>
<p>
  Exemple de script pour générer la paire de clés :
</p>
<pre class="line-numbers"><code class="language-bash" translate="No">#!/bin/bash
set -euo pipefail

NAME=${1:-}
test -z &quot;${NAME:-}&quot; &amp;&amp; NAME=&quot;brightcove-playback-auth-key-$(date +%s)&quot;
mkdir &quot;$NAME&quot;

PRIVATE_PEM=&quot;./$NAME/private.pem&quot;
PUBLIC_PEM=&quot;./$NAME/public.pem&quot;
PUBLIC_TXT=&quot;./$NAME/public_key.txt&quot;

ssh-keygen -t rsa -b 2048 -m PEM -f &quot;$PRIVATE_PEM&quot; -q -N &quot;&quot;
openssl rsa -in &quot;$PRIVATE_PEM&quot; -pubout -outform PEM -out &quot;$PUBLIC_PEM&quot; 2&gt;/dev/null
openssl rsa -in &quot;$PRIVATE_PEM&quot; -pubout -outform DER | base64 &gt; &quot;$PUBLIC_TXT&quot;

rm &quot;$PRIVATE_PEM&quot;.pub

echo &quot;Public key to saved in $PUBLIC_TXT&quot;
</code></pre>
<p>
  Exécutez le script :
</p>
<pre><code class="language-bash" translate="No">$ bash keygen.sh
</code></pre>

<details>
<summary>
  <h3 id="Example_using_Go">Exemple avec Go</h3>
</summary>
<p>
  Exemple d'utilisation du langage de programmation Go pour générer la paire de clés :
</p>
<aside class="bcls-aside bcls-aside--tip">Si vous êtes nouveau sur Go, consultez le <a href="https://golang.org/">Le langage de programmation Go</a> page d'accueil.</aside>
<pre class="line-numbers"><code class="language-bash" translate="No">package main

import (
	&quot;crypto/rand&quot;
	&quot;crypto/rsa&quot;
	&quot;crypto/x509&quot;
	&quot;encoding/base64&quot;
	&quot;encoding/pem&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;os&quot;
	&quot;path&quot;
	&quot;strconv&quot;
	&quot;time&quot;
)

func main() {
	var out string

	flag.StringVar(&amp;out, &quot;output-dir&quot;, &quot;&quot;, &quot;Output directory to write files into&quot;)
	flag.Parse()

	if out == &quot;&quot; {
		out = &quot;rsa-key_&quot; + strconv.FormatInt(time.Now().Unix(), 10)
	}

	if err := os.MkdirAll(out, os.ModePerm); err != nil {
		panic(err.Error())
	}

	priv, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		panic(err.Error())
	}

	privBytes := x509.MarshalPKCS1PrivateKey(priv)

	pubBytes, err := x509.MarshalPKIXPublicKey(priv.Public())
	if err != nil {
		panic(err.Error())
	}

	privOut, err := os.OpenFile(path.Join(out, &quot;private.pem&quot;), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		panic(err.Error())
	}

	if err := pem.Encode(privOut, &amp;pem.Block{Type: &quot;RSA PRIVATE KEY&quot;, Bytes: privBytes}); err != nil {
		panic(err.Error())
	}

	pubOut, err := os.OpenFile(path.Join(out, &quot;public.pem&quot;), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		panic(err.Error())
	}

	if err := pem.Encode(pubOut, &amp;pem.Block{Type: &quot;PUBLIC KEY&quot;, Bytes: pubBytes}); err != nil {
		panic(err.Error())
	}

	var pubEnc = base64.StdEncoding.EncodeToString(pubBytes)

	var pubEncOut = path.Join(out, &quot;public_key.txt&quot;)
	if err := ioutil.WriteFile(pubEncOut, []byte(pubEnc+&quot;\n&quot;), 0600); err != nil {
		panic(err.Error())
	}

	fmt.Println(&quot;Public key saved in &quot; + pubEncOut)
}
</code></pre>
</details>

<details>
&lt;<summary>
  <h3 id="Example_using_node_js">Exemple utilisant node.js</h3>
</summary>
<p>
  Exemple utilisant node.js pour générer la paire de clés :
</p>
<aside class="bcls-aside bcls-aside--tip">Cet exemple de script nécessite la version 11 ou ultérieure du nœud.</aside>
<pre class="line-numbers"><code class="language-javascript" translate="No">var crypto = require(&quot;crypto&quot;);
var fs = require(&quot;fs&quot;);

var now = Math.floor(new Date() / 1000);
var dir = &quot;rsa-key_&quot; + now;
fs.mkdirSync(dir);

crypto.generateKeyPair(
  &quot;rsa&quot;,
  {modulusLength: 2048},
  (err, publicKey, privateKey) =&gt; {
    fs.writeFile(
      dir + &quot;/public.pem&quot;,
      publicKey.export({ type: &quot;spki&quot;, format: &quot;pem&quot; }),
      err =&gt; {}
    );
    fs.writeFile(
      dir + &quot;/public_key.txt&quot;,
      publicKey.export({ type: &quot;spki&quot;, format: &quot;der&quot; }).toString(&quot;base64&quot;) +
        &quot;\n&quot;,
      err =&gt; {}
    );
    fs.writeFile(
      dir + &quot;/private.pem&quot;,
      privateKey.export({ type: &quot;pkcs1&quot;, format: &quot;pem&quot; }),
      err =&gt; {}
    );
  }
);

console.log(&quot;Public key saved in &quot; + dir + &quot;/public_key.txt&quot;);</code></pre>

</details>

</section>

<section class="bcls-section">
<h2 id="Register_public_key">Enregistrer la clé publique</h2>

<p>Vous utiliserez l'API Key pour enregistrer votre clé publique auprès de Brightcove.</p>
<h3>API clé</h3>
<p>
  L'API Key est utilisée pour gérer vos clés publiques avec Brightcove.
</p>
<aside class="bcls-aside bcls-aside--tip">
  <p>
    Lors de la gestion des DRM, vous pouvez également utiliser <a href="/playback-authorization/guides/additional-apis-for-pas.html">API supplémentaires pour le service d'autorisation de lecture</a>.
  </p>
</aside>


<h3>URL de base</h3>
<p>
  L'URL de base de l'API est :
</p>
<pre><code class="language-http" translate="No">https://playback-auth.api.brightcove.com</code></pre>

<h3>Chemin du compte</h3>
<p>
  Dans tous les cas, des demandes seront faites pour un compte Video Cloud spécifique. Ainsi, vous ajouterez toujours le terme comptes suivi de votre identifiant de compte à l'URL de base :
</p>
<pre><code class="language-http" translate="No">https://playback-auth.api.brightcove.com/v1/accounts/{accountID}</code></pre>

<h3>Autorisation</h3>
<p>
  Un jeton d'accès pour les demandes est requis et doit être présent dans l'en-tête Authorization :
</p>
<pre><code class="language-http" translate="No">Authorization: Bearer {access_token}</code></pre>
<p>
  Le jeton d'accès est un jeton d'accès OAuth2 temporaire qui doit être obtenu auprès du service Brightcove OAuth. Pour plus de détails sur la façon d'obtenir les informations d'identification client et de les utiliser pour récupérer des jetons d'accès, consultez le <a href="https://support.brightcove.com/overview-oauth-api-v4">Présentation de Brightcove OAuth</a>.
</p>

<h3>Autorisations</h3>
<p>
  Les demandes à l'API Key doivent être effectuées à partir de <a href="https://support.brightcove.com/oauth-api">informations d'identification du client</a> avec les autorisations suivantes :
</p>
<ul>
  <li>
    <code translate="No">video-cloud/playback-auth/key/read</code>
  </li>
  <li>
    <code translate="No">video-cloud/playback-auth/key/write</code>
  </li>
</ul>

<h3>Gérer les clés</h3>
<p>
  L'API Key prend en charge les requêtes suivantes :
</p>
<aside class="bcls-aside bcls-aside--information">
  <p>
    Remarques:
  </p>
  <ul>
    <li>
      Il n'est pas possible de modifier une clé existante, mais vous pouvez en supprimer et en créer une nouvelle.
    </li>
    <li>
      Un maximum de 3 clés peuvent être enregistrées à la fois et les clés peuvent être supprimées, pour prendre en charge la rotation des clés. En pratique, il est préférable de n'avoir qu'une seule clé.
    </li>
  </ul>
</aside>

<h4>Enregistrez une nouvelle clé :</h4>
<p>
  Mettez la valeur de votre clé publique dans le corps de la requête API. Vous pouvez trouver la clé dans le <strong>clé_publique.txt</strong> déposer.
</p>
<h5>Demander</h5>
<pre class="line-numbers"><code class="language-http" translate="No">POST /v1/accounts/{accountID}/keys
    Content-Type: application/json
    Body: {&quot;value&quot;: &quot;MFkwEwYHKoZIzj0CAQYIKoZIzj...MyeQviqploA==&quot;}
</code></pre>
<details>
<summary>
  <p id="Using_Curl">Utiliser la boucle</p>
</summary>
  <pre class="line-numbers"><code class="language-curl">curl -X POST \\ -H "Type de contenu : application/json" \\ -H "Autorisation : Porteur {access_token} " \\ -ré '{"value": "{your_public_key_value}"}'  \\ https://playback-auth.api.brightcove.com/v1/accounts/{accountID}/clés </code></pre>
<h5>Réponse</h5>
<pre class="line-numbers"><code class="language-json" translate="No">{
  &quot;id&quot;: &quot;{your_public_key_id}&quot;,
  &quot;type&quot;: &quot;public&quot;,
  &quot;algorithm&quot;: &quot;rsa&quot;,
  &quot;value&quot;: &quot;{your_public_key_value}&quot;,
  &quot;createdAt&quot;: &quot;2020-01-03T20:30:36.488Z&quot;
}</code></pre>
</details>


<h4>Liste des clés :</h4>
<p>
  Obtenez une liste des clés publiques dans votre compte.
</p>
<pre><code class="language-http" translate="No">GET /v1/accounts/{accountID}/keys</code></pre>

<h4>Obtenez une clé :</h4>
<p>
  Obtenez les détails d'une clé publique dans votre compte.
</p>
<pre><code class="language-http" translate="No">GET /v1/accounts/{accountID}/keys/{key_Id}</code></pre>

<h4>Supprimer une clé :</h4>
<p>
  Supprimez une clé publique de votre compte.
</p>
<pre><code class="language-http" translate="No">DELETE /v1/accounts/{accountID}/keys/{key_Id}</code></pre>

</section>

<section class="bcls-section">
<h2 id="Create_a_JSON_Web_Token">Créer un <span translate="No">Jeton Web JSON</span></h2>

<p>Les éditeurs créent un <a href="https://jwt.io/introduction/">Jeton Web JSON</a> (JWT). Le jeton est signé avec l'algorithme RSA à l'aide de l'algorithme de hachage SHA-256 (identifié dans la spécification JWT comme "<a href="https://ldapwiki.com/wiki/RS256">RS256</a>") Aucun autre algorithme JWT ne sera pris en charge.</p>
<p>
  Un sous-ensemble de la norme <a href="https://auth0.com/docs/tokens/jwt-claims">Revendications de jetons Web JSON</a> sera utilisé, ainsi que certaines revendications privées définies par Brightcove. Vous allez créer un <span translate="No">Jeton Web JSON</span> signé avec votre clé privée.
</p>

<h3>Réclamations pour la livraison d'URL statiques</h3>
<p>
  Pour une liste des allégations pouvant être utilisées, consultez le <a href="node/18961/">Livraison d'URL statique</a> document.
</p>

<h3>Demandes d'autorisation de lecture</h3>
<p>
  Les allégations suivantes peuvent être utilisées avec <a href="/playback-authorization/getting-started/overview-playback-authorization-service.html">Service d'autorisation de lecture de Brightcove</a>.
</p>

<table class="bcls-table">
      <thead class="bcls-table__head">
        <tr>
          <th>Champ</th>
          <th>Taper</th>
          <th>Obligatoire</th>
          <th>La description</th>
        </tr>
      </thead>
      <tbody class="bcls-table__body">
        <tr>
          <td><code translate="No">accid</code></td>
          <td>Chaîne de caractères</td>
          <td>Oui</td>
          <td>L'identifiant du compte qui possède le contenu en cours de lecture</td>
        </tr>
        <tr>
          <td><code translate="No">exp</code></td>
          <td>Entier</td>
          <td>Oui</td>
          <td>Temps pendant lequel ce jeton ne sera plus valide, en secondes depuis l'époque. Ne doit pas être plus de 30 jours à compter de <code translate="No">iat</code></td>
        </tr>
        <tr>
          <td><code translate="No">iat</code></td>
          <td>Entier</td>
          <td>Oui</td>
          <td>Heure à laquelle ce jeton a été émis, en secondes depuis l'époque</td>
        </tr>
        <tr>
          <td><code translate="No">conid</code></td>
          <td>Chaîne de caractères</td>
          <td></td>
          <td>S'il est présent, ce jeton n'autorisera la récupération de licence que pour un identifiant vidéo Video Cloud spécifique.
            <br /><br />
            Doit être un identifiant vidéo valide.
          </td>
        </tr>
        <!-- <tr> This is internal use only!!
          <td><code translate="No">crt </code></td>
          <td>String</td>
          <td></td>
          <td>Customer Rights Token used for DRM rights management (DRM Only).
          </td>
        </tr> -->
        <tr>
          <td><code translate="No">maxip</code></td>
          <td>Entier</td>
          <td></td>
          <td>S'il est présent, ce jeton ne pourra être utilisé que par ces nombreuses adresses IP différentes. (DRM et AES-128)
            <br /><br />
            Requis pour le suivi de session.
          </td>
        </tr>
        <tr>
          <td><code translate="No">maxu</code></td>
          <td>Entier</td>
          <td></td>
          <td>
              S'il est présent, ce jeton ne sera valide que pour ce nombre de demandes de licence. (DRM et AES-128)
            <br><br>
            <ul>
              <li>
                Pour HLSe, les joueurs feront plusieurs demandes lors de la lecture d'une vidéo, généralement une par rendu. Les <code translate="No">maxu</code> doit être suffisamment élevé pour tenir compte de ces demandes supplémentaires.
              </li>
              <li>
                Pour les DRM, une demande de licence est effectuée par lecture
              </li>
            </ul>
              Requis pour le suivi de session.
          </td>
        </tr>
        <tr>
          <td><code translate="No">ua</code></td>
          <td>Chaîne de caractères</td>
          <td></td>
          <td>S'il est présent, ce token ne sera valable que pour les requêtes de cet User-Agent.
            <br /><br />
            Ce champ n'est pas validé.
          </td>
        </tr>
      </tbody>
    </table>

    <h3>Revendications pour les droits de lecture</h3>
    <p>
      Les allégations suivantes peuvent être utilisées avec <a href="/playback-rights/getting-started/overview-epa.html">Service de gestion des droits de lecture de Brightcove</a>.
    </p>
    <aside class="bcls-aside bcls-aside--information">Lorsque vous utilisez les droits de lecture avec DRM, vous ne pouvez pas utiliser AES-128.</aside>

    <table class="bcls-table">
          <thead class="bcls-table__head">
            <tr>
              <th>Champ</th>
              <th>Taper</th>
              <th>Obligatoire</th>
              <th>Obligatoire pour les limites de flux simultanés</th>
              <th>DRM uniquement</th>
              <th>La description</th>
            </tr>
          </thead>
          <tbody class="bcls-table__body">
            <tr>
              <td><code translate="No">accid</code></td>
              <td>Chaîne de caractères</td>
              <td>Oui</td>
              <td></td>
              <td></td>
              <td>L'identifiant du compte qui possède le contenu en cours de lecture</td>
            </tr>
            <tr>
              <td><code translate="No">exp</code></td>
              <td>Entier</td>
              <td>Oui</td>
              <td></td>
              <td></td>
              <td>Temps pendant lequel ce jeton ne sera plus valide, en secondes depuis l'époque. Ne doit pas être plus de 30 jours à compter de <code translate="No">iat</code></td>
            </tr>
            <tr>
              <td><code translate="No">iat</code></td>
              <td>Entier</td>
              <td>Oui</td>
              <td></td>
              <td></td>
              <td>Heure à laquelle ce jeton a été émis, en secondes depuis l'époque</td>
            </tr>
            <tr>
              <td><code translate="No">nbf</code></td>
              <td>Entier</td>
              <td></td>
              <td></td>
              <td></td>
              <td>Heure à laquelle ce jeton commencera à être valide, en secondes depuis l'époque</td>
            </tr>
            <tr>
              <td><code translate="No">pkid</code></td>
              <td>Chaîne de caractères</td>
              <td></td>
              <td></td>
              <td></td>
              <td>L'identifiant de clé publique utilisé pour vérifier ce jeton. Il est enregistré auprès du service d'autorisation de lecture de Brightcove et doit utiliser le format de clé RSA.
                <br /><br />
                Si <code translate="No">pkid</code> est spécifié, nous validons le jeton avec la clé spécifiée.
                <br /><br />
                Sinon <code translate="No">pkid</code> est spécifié, nous récupérons toutes les clés du compte et essayons de les valider toutes.
              </td>
            </tr>
            <tr>
              <td><code translate="No">prid</code></td>
              <td>Chaîne de caractères</td>
              <td></td>
              <td></td>
              <td></td>
              <td>UNE <code translate="No">playback_rights_id</code>. Utilisé pour remplacer l'identifiant défini dans le catalogue pour cette vidéo
                <br /><br />
                Ce champ n'est pas validé.
              </td>
            </tr>
            <tr>
              <td><code translate="No">tags</code></td>
              <td>Tableau &lt;chaînes&gt;</td>
              <td></td>
              <td></td>
              <td></td>
              <td>s'il est présent, ce jeton n'est valable que pour les balises répertoriées autorisées à la lecture.</td>
            </tr>
            <tr>
              <td><code translate="No">vids</code></td>
              <td>Tableau &lt;chaînes&gt;</td>
              <td></td>
              <td></td>
              <td></td>
              <td>S'il est présent, ce jeton n'autorisera la récupération de licence que pour un ensemble d'identifiants vidéo.</td>
            </tr>
             <tr>
              <td><code translate="No">cbeh</code></td>
              <td>Chaîne de caractères</td>
              <td></td>
              <td></td>
              <td>Oui</td>
              <td>Réglez la valeur sur <code translate="No">BLOCK_NEW</code> pour permettre aux limites de flux simultanés de bloquer toute nouvelle demande, même du même utilisateur, lorsque le nombre maximum de flux est atteint.
                <br /><br />
                Réglez la valeur sur <code translate="No">BLOCK_NEW_USER</code> de bloquer toute nouvelle demande d'un nouvel utilisateur uniquement lorsque le nombre maximum de flux est atteint.
                <br /><br />
                La valeur par défaut bloque le flux le plus ancien lorsque le nombre maximal de flux est atteint.
                <br /><br />
          Limites de flux simultanés : Optionnel
              </td>
            </tr>
            <tr>
              <td><code translate="No">cexp</code></td>
              <td>Chaîne de caractères</td>
              <td></td>
              <td></td>
              <td>Oui</td>
              <td>Expiration simultanée de la session - La valeur par défaut est 2 fois la durée du contenu ou 15 minutes, selon la plus longue des deux.
                <br /><br />
                Cela définit la durée de validité de la session, après quoi l'utilisateur final doit démarrer une nouvelle session pour continuer la lecture. Exemple: <code translate="No">2h</code> ou <code translate="No">42m</code>
                <br /><br />
          Limites de flux simultanés : Optionnel
              </td>
            </tr>
            <tr>
              <td><code translate="No">climit</code></td>
              <td>Entier</td>
              <td></td>
              <td>Oui</td>
              <td>Oui</td>
              <td>Lorsque ce champ est inclus, il active les limites de flux simultanées ainsi que les demandes de renouvellement de licence. Cette valeur indique le nombre d'observateurs simultanés autorisés.
                <br /><br />
          Limites de flux simultanés : Obligatoire
        </td>
            </tr>
            <tr>
              <td><code translate="No">dlimit</code></td>
              <td>Entier</td>
              <td></td>
              <td></td>
              <td>Oui</td>
              <td>Lorsque ce champ est inclus, il contrôle le nombre d'appareils pouvant être associés à l'utilisateur spécifié (<code translate="No">uid</code>). La valeur doit être &gt; <code translate="No">0</code>.
                <br /><br />
                Les appareils précédemment autorisés continueront de fonctionner si le <code translate="No">dlimit</code> la valeur est supprimée dans les demandes ultérieures.
                <br /><br />
                Exemple : si la valeur est définie sur <code translate="No">3</code> , l'utilisateur peut jouer sur les appareils A, B et C (tous seraient autorisés). Essayer de jouer sur l'appareil D serait refusé.
                <br /><br />
                Si la valeur est changée en <code translate="No">1</code> , l'utilisateur peut toujours jouer sur les 3 appareils A, B et C, à moins que les appareils ne soient révoqués manuellement en gérant les appareils avec le <a href="/playback-rights/references/reference.html#operation/GetDevices">API des appareils</a>.
                <br /><br />
            Enregistrement de l'appareil : Obligatoire
              </td>
            </tr>
            <tr>
              <td><code translate="No">sid</code></td>
              <td>Chaîne de caractères</td>
              <td></td>
              <td></td>
              <td>Oui</td>
              <td>La spécification de l'ID de session du flux actuel vous permet de contrôler la manière dont une session est définie. Par défaut, une session est définie comme User-Agent (navigateur) + adresse IP + identifiant vidéo.
                <br /><br />
                  Par exemple, vous pouvez assouplir la définition de session en adresse IP + identifiant vidéo.
                  <br /><br />
            Limites de flux simultanés : Optionnel
              </td>
            </tr>
            <tr>
              <td><code translate="No">uid</code></td>
              <td>Chaîne de caractères</td>
              <td></td>
              <td></td>
              <td>Oui</td>
              <td>L'identifiant de l'utilisateur final. Ce champ est utilisé pour corréler plusieurs sessions afin d'appliquer des limites de flux simultanées.
                <br /><br />
            Enregistrement de l'appareil : Obligatoire
              </td>
            </tr>
          </tbody>
        </table>

<h3>Générer un jeton</h3>
<p>
  Les bibliothèques sont généralement disponibles pour générer des jetons JWT. Pour plus de détails, consultez le <a href="https://jwt.io/">Jetons Web JSON</a> placer.
</p>
<h4>
  Exemple de script bash :
</h4>
<p>
  Exemple de script pour générer le jeton JWT :
</p>
<pre class="line-numbers"><code class="language-bash" translate="No">#! /usr/bin/env bash
# Static header fields.
HEADER='{
	&quot;type&quot;: &quot;JWT&quot;,
	&quot;alg&quot;: &quot;RS256&quot;
}'

payload='{
	&quot;pkid&quot;: &quot;{your_public_key_id}&quot;,
	&quot;accid&quot;: &quot;{your_account_id}&quot;
}'

# Use jq to set the dynamic `iat` and `exp`
# fields on the payload using the current time.
# `iat` is set to now, and `exp` is now + 1 second.
PAYLOAD=$(
	echo &quot;${payload}&quot; | jq --arg time_str &quot;$(date +%s)&quot; \
	'
	($time_str | tonumber) as $time_num
	| .iat=$time_num
	| .exp=($time_num + 60 * 60)
	'
)

function b64enc() { openssl enc -base64 -A | tr '+/' '-_' | tr -d '='; }

function rs_sign() { openssl dgst -binary -sha256 -sign playback-auth-keys/private.pem ; }

JWT_HDR_B64=&quot;$(echo -n &quot;$HEADER&quot; | b64enc)&quot;
JWT_PAY_B64=&quot;$(echo -n &quot;$PAYLOAD&quot; | b64enc)&quot;
UNSIGNED_JWT=&quot;$JWT_HDR_B64.$JWT_PAY_B64&quot;
SIGNATURE=$(echo -n &quot;$UNSIGNED_JWT&quot; | rs_sign | b64enc)

echo &quot;$UNSIGNED_JWT.$SIGNATURE&quot;
</code></pre>
<p>
  Exécutez le script :
</p>
<pre><code class="language-bash" translate="No">$ bash jwtgen.sh
</code></pre>
<p>

</p>
<details>
<summary>
  <h4 id="Example_using_Go_token">Exemple avec Go</h4>
</summary>
<p>
  Voici un exemple d'implémentation Go de référence (en tant qu'outil cli) pour générer des jetons sans utiliser de bibliothèque tierce :
</p>
<aside class="bcls-aside bcls-aside--tip">Si vous êtes nouveau sur Go, consultez le <a href="https://golang.org/">Le langage de programmation Go</a> page d'accueil.</aside>
<pre class="line-numbers"><code class="language-bash" translate="No">package main

import (
	&quot;crypto&quot;
	&quot;crypto/ecdsa&quot;
	&quot;crypto/rand&quot;
	&quot;crypto/rsa&quot;
	&quot;crypto/sha256&quot;
	&quot;crypto/x509&quot;
	&quot;encoding/base64&quot;
	&quot;encoding/json&quot;
	&quot;encoding/pem&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;os&quot;
	&quot;strings&quot;
	&quot;time&quot;
)

// Header is the base64UrlEncoded string of a JWT header for the RS256 algorithm
const RSAHeader = &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9&quot;

// Header is the base64UrlEncoded string of a JWT header for the EC256 algorithm
const ECHeader = &quot;eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9&quot;

// Claims represents constraints that should be applied to the use of the token
type Claims struct {
	Iat   float64 `json:&quot;iat,omitempty&quot;`   // Issued At
	Exp   float64 `json:&quot;exp,omitempty&quot;`   // Expires At
	Accid string  `json:&quot;accid,omitempty&quot;` // Account ID
	Conid string  `json:&quot;conid,omitempty&quot;` // Content ID
	Maxu  float64 `json:&quot;maxu,omitempty&quot;`  // Max Uses
	Maxip float64 `json:&quot;maxip,omitempty&quot;` // Max IPs
	Ua    string  `json:&quot;ua,omitempty&quot;`    // User Agent
}

func main() {
	var key, algorithm string

	c := Claims{Iat: float64(time.Now().Unix())}

	flag.StringVar(&amp;key, &quot;key&quot;, &quot;&quot;, &quot;Path to private.pem key file&quot;)
	flag.StringVar(&amp;c.Accid, &quot;account-id&quot;, &quot;&quot;, &quot;Account ID&quot;)
	flag.StringVar(&amp;c.Conid, &quot;content-id&quot;, &quot;&quot;, &quot;Content ID (eg, video_id or live_job_id)&quot;)
	flag.Float64Var(&amp;c.Exp, &quot;expires-at&quot;, float64(time.Now().AddDate(0, 0, 1).Unix()), &quot;Epoch timestamp (in seconds) for when the token should stop working&quot;)
	flag.Float64Var(&amp;c.Maxu, &quot;max-uses&quot;, 0, &quot;Maximum number of times the token is valid for&quot;)
	flag.Float64Var(&amp;c.Maxip, &quot;max-ips&quot;, 0, &quot;Maximum number of unique IP addresses the token is valid for&quot;)
	flag.StringVar(&amp;c.Ua, &quot;user-agent&quot;, &quot;&quot;, &quot;User Agent that the token is valid for&quot;)
	flag.StringVar(&amp;algorithm, &quot;algo&quot;, &quot;&quot;, &quot;Key algorithm to use for signing. Valid: ec256, rsa256&quot;)
	flag.Parse()

	if key == &quot;&quot; {
		fmt.Printf(&quot;missing required flag: -key\n\n&quot;)
		flag.Usage()
		os.Exit(1)
	}

	if algorithm == &quot;&quot; {
		fmt.Printf(&quot;missing required flag: -algo\n\n&quot;)
		flag.Usage()
		os.Exit(2)
	}

	if algorithm != &quot;rsa256&quot; &amp;&amp; algorithm != &quot;ec256&quot; {
		fmt.Printf(&quot;missing valid value for -algo flag. Valid: rsa256, ec256\n\n&quot;)
		flag.Usage()
		os.Exit(3)
	}

	if c.Accid == &quot;&quot; {
		fmt.Printf(&quot;missing required flag: -account-id\n\n&quot;)
		flag.Usage()
		os.Exit(4)
	}

	bs, err := json.Marshal(c)
	if err != nil {
		fmt.Println(&quot;failed to marshal token to json&quot;, err)
		os.Exit(5)
	}

	kbs, err := ioutil.ReadFile(key)
	if err != nil {
		fmt.Println(&quot;failed to read private key&quot;, err)
		os.Exit(6)
	}

	if algorithm == &quot;rsa256&quot; {
		processRSA256(kbs, bs)
	} else {
		processEC256(kbs, bs)
	}
}

func processRSA256(kbs, bs []byte) {
	block, _ := pem.Decode(kbs)
	if block == nil {
		fmt.Println(&quot;failed to decode PEM block containing private key&quot;)
		os.Exit(7)
	}

	if block.Type != &quot;RSA PRIVATE KEY&quot; {
		fmt.Println(&quot;failed to decode PEM block containing private key&quot;)
		os.Exit(8)
	}

	pKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		fmt.Println(&quot;failed to parse rsa private key&quot;, err)
		os.Exit(9)
	}

	message := RSAHeader + &quot;.&quot; + base64.RawURLEncoding.EncodeToString(bs)

	hash := crypto.SHA256
	hasher := hash.New()
	_, _ = hasher.Write([]byte(message))
	hashed := hasher.Sum(nil)

	r, err := rsa.SignPKCS1v15(rand.Reader, pKey, hash, hashed)
	if err != nil {
		fmt.Println(&quot;failed to sign token&quot;, err)
		os.Exit(10)
	}

	sig := strings.TrimRight(base64.RawURLEncoding.EncodeToString(r), &quot;=&quot;)

	fmt.Println(message + &quot;.&quot; + sig)
}

func processEC256(kbs, bs []byte) {
	block, _ := pem.Decode(kbs)
	if block == nil {
		fmt.Println(&quot;failed to decode PEM block containing private key&quot;)
		os.Exit(7)
	}

	if block.Type != &quot;EC PRIVATE KEY&quot; {
		fmt.Println(&quot;failed to decode PEM block containing private key&quot;)
		os.Exit(8)
	}

	pkey, err := x509.ParseECPrivateKey(block.Bytes)
	if err != nil {
		fmt.Println(&quot;failed to parse ec private key&quot;, err)
		os.Exit(9)
	}

	message := ECHeader + &quot;.&quot; + base64.RawURLEncoding.EncodeToString(bs)
	hash := sha256.Sum256([]byte(message))

	r, s, err := ecdsa.Sign(rand.Reader, pkey, hash[:])
	if err != nil {
		fmt.Println(&quot;failed to sign token&quot;, err)
		os.Exit(10)
	}

	curveBits := pkey.Curve.Params().BitSize

	keyBytes := curveBits / 8
	if curveBits%8 &gt; 0 {
		keyBytes++
	}

	rBytes := r.Bytes()
	rBytesPadded := make([]byte, keyBytes)
	copy(rBytesPadded[keyBytes-len(rBytes):], rBytes)

	sBytes := s.Bytes()
	sBytesPadded := make([]byte, keyBytes)
	copy(sBytesPadded[keyBytes-len(sBytes):], sBytes)

	out := append(rBytesPadded, sBytesPadded...)

	sig := base64.RawURLEncoding.EncodeToString(out)
	fmt.Println(message + &quot;.&quot; + sig)
}
</code></pre>
</details>

<h4>Résultats</h4>
<p>
  Voici un exemple de jeton décodé utilisant <a href="https://jwt.io/">https://JWT.io</a> spécifiant l'ensemble complet des revendications :
</p>
<p>
  ENTÊTE:
</p>
<pre class="line-numbers"><code class="language-json" translate="No">{
  &quot;alg&quot;: &quot;RS256&quot;,
  &quot;type&quot;: &quot;JWT&quot;
}
</code></pre>

<p>
  CHARGE UTILE:
</p>
<pre class="line-numbers"><code class="language-json" translate="No">{
  &quot;accid&quot;: &quot;1100863500123&quot;,
  &quot;conid&quot;: &quot;51141412620123&quot;,
  &quot;exp&quot;: 1554200832,
  &quot;iat&quot;: 1554199032,
  &quot;maxip&quot;: 10,
  &quot;maxu&quot;: 10,
  &quot;ua&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&quot;
}
</code></pre>
</section>

<section class="bcls-section">
<h2 id="Test_playback">Tester la lecture</h2>

<p>Bien que cela ne soit pas obligatoire, vous souhaiterez peut-être tester la lecture vidéo avant de configurer un lecteur.</p>
<p>
  Demander la lecture :
</p>
<pre class="line-numbers"><code class="language-http" translate="No">curl -X GET \
 -H 'Authorization: Bearer {JWT}' \
 https://edge-auth.api.brightcove.com/playback/v1/accounts/{your_account_id}/videos/{your_video_id}
</code></pre>
</section>

</article>